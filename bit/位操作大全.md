# 位运算

## 位运算基本操作

符号 | 描述 | 运算规则 | 举例
--- | --- | --- | ---
a << n |  左移 | a的每个二进制位左移n位, <br>高位丢弃，低位补零，<br>其值为 a * 2 ^n | 1 << 0  = 1 <br> 1 << 1 = 2
a >> n |  算术右移 | a的每个二进制位右移n位, <br>低位丢弃，高位补符号位，<br>其值为： 符号位 * a / (n + 1) | 1 >> 0  = 1 <br> 1 >> 1 = 0 <br> 2 >> 1 = 1 <br> -2 >> 1 = -1
a >>> n |  算术右移 | a的每个二进制位右移n位, <br>低位丢弃，高位0 | 1 >>> 0  = 1 <br> 1 >>> 1 = 0 <br> 2 >>> 1 = 1 <br> -2 >>> 1 = 2147483647
a & b | 与 | 每个二进制位都为1时，结果才为1 | 2 & 0 = 0<br> (2 \| 1) & 2 = 2 <br> (2 \| 1) & 1 = 1
a \| b | 或 | 每个二进制位都为0时，结果才为0 | 2 \| 0 = 2 <br> 2 \| 1 = 3 <br> 2 \| 2 = 2
~a | 取反 | 二进制位0变为1， 1变为 0  | ~0 = -1 <br> ~1 = -2 <br> ~3 = -4
a ^ b | 异或 | 两个二进制位相同为0，不相同为1 | 1 ^ 0 = 1<br> 1 ^ 1 = 0 <br> (1 \| 2 ) ^ 2 = 1 <br> (1 \| 2 ) ^ 1 = 2



###  左移操作 a << n

将a的二进制表示的数据每一位向左移n位。左边超出的位截掉，右边不足的位补0
 
把一个整数值左移n位的值等于 a 乘以 2的n次方的值 即
`a << n = a * 2^n` 

```
int a = 2;
System.out.println( a + " << 1 = " + (a << 1)); // a * 2;
System.out.println( a + " << 2 = " + (a << 2)); // a * 2 * 2;
System.out.println( a + " << 3 = " + (a << 3)); // a * 2 * 2 * 2;
System.out.println( a + " << 4 = " + (a << 4)); // a * 2 * 2 * 2 * 2;

输出为：

2 << 1 = 4
2 << 2 = 8
2 << 3 = 16
2 << 4 = 32
```
 
### 右移操作

右移操作分为算术右移和逻辑右移。

* 算术右移：将A的二进制表示的每一位向右移n位，右边超出的位截掉，左边不足的位补符号位的数。
* 逻辑右移：将A的二进制表示的每一位向右移n位，右边超出的位截掉，左边不足的位补0

Java中算术右移：a >> n, 逻辑右移： a >>> n

举例：

```
int a = -8;
System.out.println("算术右移");
System.out.println( a + " >> 1 = " + (a >> 1) + " 二进制："+ BitUtil.interToBinaryString( a >> 1));
System.out.println( a + " >> 2 = " + (a >> 2) + " 二进制："+ BitUtil.interToBinaryString( a >> 2));
System.out.println( a + " >> 3 = " + (a >> 3) + " 二进制："+ BitUtil.interToBinaryString( a >> 3));
System.out.println( a + " >> 4 = " + (a >> 4) + " 二进制："+ BitUtil.interToBinaryString( a >> 4));

System.out.println("逻辑右移");
System.out.println( a + " >>> 1 = " + (a >>> 1) + " 二进制："+ BitUtil.interToBinaryString( a >>> 1));
System.out.println( a + " >>> 2 = " + (a >>> 2) + " 二进制："+ BitUtil.interToBinaryString( a >>> 2));
System.out.println( a + " >>> 3 = " + (a >>> 3) + " 二进制："+ BitUtil.interToBinaryString( a >>> 3));
System.out.println( a + " >>> 4 = " + (a >>> 4) + " 二进制："+ BitUtil.interToBinaryString( a >>> 4));
   
输出结果为：
   
算术右移
-8 >> 1 = -4 二进制：11111111111111111111111111111100
-8 >> 2 = -2 二进制：11111111111111111111111111111110
-8 >> 3 = -1 二进制：11111111111111111111111111111111
-8 >> 4 = -1 二进制：11111111111111111111111111111111
逻辑右移
-8 >>> 1 = 2147483644 二进制：01111111111111111111111111111100
-8 >>> 2 = 1073741822 二进制：00111111111111111111111111111110
-8 >>> 3 = 536870911 二进制：00011111111111111111111111111111
-8 >>> 4 = 268435455 二进制：00001111111111111111111111111111
```

### 按位与操作 a & b

将a 和 b 的表示的二进制数据按位进行与操作，只有两个对应的二进制位都为1时，才为1.

a | 操作符 | b | 结果
--- | --- | --- | ---
1 | & | 1 | 1
1 | & | 0 | 0
0 | & | 1 | 0
0 | & | 0 | 0

### 按位或操作 a | b

将A和B的二进制表示的每一位进行或操作，只要两个对应的二进制位有一个为1，就为1.

a | 操作符 | b | 结果
--- | --- | --- | ---
1 | \| | 1 | 1
1 | \| | 0 | 1
0 | \| | 1 | 1
0 | \| | 0 | 0

### 按位非操作 a

将 a 的二进制表示的每一位进行取反操作，如果对应的二进制位为0，则结果为1，如果为0，则结果为1


```
1的二进制标识为：0000 0000 0000 0000 0000 0000 0000 0001

~1的二进制标识为：1111 1111 1111 1111 1111 1111 1111 1110 

所以~1的值为：-2
```

### 按异或操作 a\^b

将 a 和 b的二进制表示的每一位进行异或操作，如果对应的二进制位不同，结果为1，否则为0

a | 操作符 | b | 结果
--- | --- | --- | ---
1 | ^ | 1 | 0
1 | ^ | 0 | 1
0 | ^ | 1 | 1
0 | ^ | 0 | 0

异或操作有几个特点：

两个数相同那么异或为0： a ^ a = 0
一个数a和0 进行异或其值为a: a ^ 0 = a
异或 满足交互律：a ^ a ^ b = a ^ b ^ a

## 常见位操作

### 判断奇偶数

一个数的最末位为0就是偶数，为1就是奇数。所以对于一个数`a`，如果其 `a & 1` 等于 `0` ，那么 `a` 就是偶数，如果 `a & 1 `不等于`0`，那么`a` 就是奇数。


```
2 & 1 = 0；
4 & 1 = 0；
3 & 1 = 1；
101 & 1 = 1；
```

### 求一个数乘以2的n次方
求一个数乘以2的n次方就是将该数左移n位


```java

3 << 2 = 12
2 << 2 = 8
```

### 交互两个数字: a, b

利用异或可以很方便的交换两个数字，异或操作有下面3个特点：
两个数相同那么异或为0： a ^ a = 0
一个数a和0 进行异或其值为a: a ^ 0 = a
异或 满足交互律：a ^ a ^ b = a ^ b ^ a


```java
a = a ^ b;
b = b ^ a; // b = b ^ a ^ b = b ^ b ^ a = a
a = a ^ b; // a = a ^ b ^ a = b
```

### 获取符号位

在Java中int类型为32位，将其右移移31位，就可以等到符号位了


```
-1 >> 31;  // -1
1 >> 31;  // 0;
```

### 数值取反，整数变负数，负数变成整数

数值交换符号，只需要取反后加1即可。

```java

~-2 + 1 = 2；
~2 + 1 = -2；
```

### 求二进制a中第n位的是0还是1

( a >> (n-1) ) & 0x01 是否等于1

### 将二进制数中第n位置为1

a | ( 1 << n) ， 假定a = 5， n = 1;

  |  对应二进制
---|---
a                |  0101
1 << n        |  0010
a \| (1 << n) | 0110

### 将二进制数中第n位设置0

a & ~(1 << n)  假定a = 5， n = 2;

  |  对应二进制
---|---
a                |  0101
~(1 << n )   |  1011
a & ~(1 << n) | 0001

### 将二进制位中第n位取反

### 求一个数n的二进制中1的个数

如果 n  & 1 等于1 那么其二进制的最后一位为1，然后不断的左移n，进行 n & 1是否等于1进行判断，直到n 小于等于0为止。


```java

int n = 5;
int num = 0;
do {
    if ( (n & 1) == 1){
        num ++;
    }
}while ( (n = (n >> 1)) > 0);
```


# 参考

* [位运算面试题大总结](https://juejin.im/post/58da165061ff4b006cdd260b)
* [有趣的二进制2—高效位运算](https://juejin.im/post/5a14dc876fb9a044fa197f2e)


 

